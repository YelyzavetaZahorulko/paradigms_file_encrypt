# Control questions

_1. Enumerate main OOP principles._

Encapsulation 
- приховуємо функціонал, залишаємо інтерфейс(private, public)
- protected - доступ до сутності лише для класів свого пакету і нащадків класу

Inheritance
- наслідування( те що зліва є тим що справа)

Polymorphism 
- якщо об'єкт має більше ніж один тип
- на етапі compilation(явно в коді), на етапі runtime(за допомогою шаблонів)
- який дозволяє викликом перевизначеного методу через змінну батьківського класу отримати поведінку, яка буде відповідати реальному похідному класу, на який посилається ця змінна.

Abstraction

_2. Explain the advantages of object-oriented programming._

- ООП заохочує використання об'єктів, які об'єднують дані та поведінку разом, роблячи код більш модульним.
Це полегшує управління та підтримку, оскільки зміни в одній частині програми з меншою ймовірністю вплинуть на інші частини.

- Можливість повторного використання:
Класи та об'єкти можна повторно використовувати в різних програмах. 
Після створення класу його можна використовувати для створення декількох об'єктів, що сприяє повторному використанню коду та зменшенню надмірності.

- ООП полегшує підтримку та оновлення коду. Помилки можуть бути виправлені, а нові функції можуть бути додані з мінімальним втручанням в існуючий код.

- Принципи ООП, такі як багаторазове використання, модульність та абстракція, можуть призвести до більш ефективних процесів розробки, оскільки код легше повторно використовувати та підтримувати.

- Чітка структура та модульність ООП полегшує командну роботу, оскільки різні розробники можуть працювати над різними частинами програми незалежно, не викликаючи конфліктів.

_3. Explain object lifetimes._
- тривалість існування об'єкта в пам'яті.
  
Три основні фази:
**Створення (Instantiation)** - життєвий цикл об'єкта починається з моменту його створення, як правило, через екземпляр класу.
На цій фазі для об'єкта виділяється пам'ять і викликається його конструктор для ініціалізації його стану.

**Usage:** - Після створення об'єкт можна використовувати у програмі. На цій фазі до об'єкта можна викликати методи, а також отримати доступ до його атрибутів або змінити їх.
Об'єкт залишається в пам'яті і є частиною виконання програми, виконуючи своє призначення.

**Знищення (Finalization/Deallocation):** - Час життя об'єкта закінчується, коли він більше не потрібен, і його знищують, звільняючи пам'ять, яку він займав.
програміст повинен явно видалити об'єкт, щоб звільнити пам'ять, як правило, за допомогою деструктора.

_4. Explain the need of constructor/destructor._

**Конструктор** - це спеціальна функція-член класу, яка автоматично викликається при створенні екземпляру об'єкта класу. 
Його основне призначення - ініціалізація членів даних об'єкта та виділення ресурсів, якщо це необхідно.
1. Ініціалізація:
Конструктори гарантують, що об'єкт починає своє життя у правильному стані. Вони можуть встановлювати значення за замовчуванням для членів даних або використовувати параметри для їх ініціалізації.
2. Перевантаження:
Багато мов ООП підтримують перевантаження конструкторів, що означає, що ви можете мати декілька конструкторів з різними списками параметрів.
 Це дозволяє використовувати різні способи ініціалізації об'єкта.
3. Інкапсуляція:
Конструктори сприяють інкапсуляції, гарантуючи, що деталі ініціалізації об'єкта приховані від користувача. Користувачеві потрібно лише знати, як створити об'єкт, а не як він налаштований зсередини.
4. Розподіл ресурсів:
Конструктори можуть виділяти ресурси, такі як пам'ять, дескриптори файлів або мережеві з'єднання, якими об'єкт буде керувати протягом свого життя.

**Деструктор** - це спеціальна функція-член, яка автоматично викликається, коли об'єкт виходить за межі області видимості або явно видаляється. 
Її основне призначення - звільнити ресурси, які об'єкт міг отримати протягом свого життя.
1. Виділення ресурсів:
Деструктори звільняють ресурси, такі як пам'ять, дескриптори файлів або мережеві з'єднання, щоб уникнути витоку ресурсів, який може призвести до погіршення продуктивності або аварійного завершення роботи програми.
2. Очищення:
Деструктори виконують необхідні завдання з очищення, забезпечуючи впорядковане завершення роботи об'єкта та відсутність залишкового стану, який може вплинути на подальші операції.
3. Автоматичний виклик:
Деструктори автоматично викликаються системою виконання, усуваючи необхідність ручного очищення програмістом, що зменшує ймовірність помилок.
4. Єдиний деструктор:
На відміну від конструкторів, які можуть бути перевантажені, у класі є лише один деструктор, який не приймає параметрів і не повертає жодного значення.

_5. Provide examples how objects can interact one with another._

**1. Композиція**
Один об'єкт може складатися з інших об'єктів. Це означає, що об'єкт може мати членами екземпляри інших класів.( машина та двигун)

**2. Агрегація**
Агрегація - це особлива форма композиції, де об'єкти, що містяться в ній, можуть існувати незалежно від батьківського об'єкта.(машина та колесо)

**3. Успадкування**
Об'єкти можуть взаємодіяти через успадкування, коли один клас успадковує властивості та поведінку іншого класу.(собака і лапи)

**4. Виклик методів**
Об'єкти можуть взаємодіяти, викликаючи методи один одного.(документ і принтер)

**5. Обробка подій**
Об'єкти можуть взаємодіяти через обробку подій, коли один об'єкт реагує на події, викликані іншим об'єктом.

_6. What advantages are in the chunk-based logic?_
передбачає розбиття програми або системи на менші, керовані та багаторазово використовувані частини або модулі.

1. Модульність
Ізоляція: Кожна частина або модуль є самодостатньою і може розроблятися, тестуватися та налагоджуватися незалежно.
Можливість багаторазового використання: Частини можуть бути повторно використані в різних частинах програми або навіть в різних проектах, зменшуючи надмірність та зусилля.

3. Обслуговуваність
Спрощені оновлення: Зміни в одному фрагменті не обов'язково впливають на інші, що робить оновлення та супровід простішими і менш ризикованими.
Легше налагодження: Ізольовані частини спрощують виявлення та виправлення помилок, оскільки проблеми можна відстежити до конкретного модуля

3. Масштабованість
Інкрементна розробка: Нові функції та можливості можна додавати поступово, створюючи нові фрагменти або модифікуючи існуючі, не переробляючи всю систему.
Командна співпраця: Різні команди або члени команди можуть працювати над окремими частинами одночасно, підвищуючи продуктивність і зменшуючи вузькі місця

4. Читабельність та зрозумілість
Спрощена база коду: Розбиття складної логіки на менші, зрозумілі частини робить кодову базу легшою для читання і розуміння.
Документація: Кожна частина може бути задокументована окремо, з чітким поясненням її призначення та функціональності.

5. Тестування
Модульне тестування: Кожна частина може бути протестована незалежно, що сприяє ретельному та ефективному модульному тестуванню.
Тестування інтеграції: Після перевірки окремих частин можна протестувати їхню взаємодію, щоб переконатися, що вони працюють разом, як очікувалося.

6. Гнучкість
Адаптивність: Частини можуть бути легко замінені або модернізовані без впливу на загальну систему, що забезпечує гнучкість і адаптивність у відповідь на мінливі вимоги.
Конфігурація: Різні конфігурації та комбінації блоків можуть бути використані для створення різних варіантів системи.

7. Оптимізація продуктивності
Сфокусована оптимізація: Критично важливі для продуктивності фрагменти можуть бути визначені та оптимізовані індивідуально без необхідності переписування всієї системи.
Ліниве завантаження: Частини можуть завантажуватися на вимогу, зменшуючи час початкового завантаження і покращуючи загальну продуктивність.

9. Інкапсуляція
Приховування даних: Кожен чанк може інкапсулювати свої дані та внутрішню роботу, відкриваючи лише необхідні інтерфейси. Це сприяє приховуванню даних і знижує ризик ненавмисного втручання.
Зрозумілість інтерфейсу: Чіткі інтерфейси між блоками визначають, як вони взаємодіють, роблячи загальну архітектуру системи більш зрозумілою та надійною.
